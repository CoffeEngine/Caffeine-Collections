<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Caffeine Data Structure: Vector</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Caffeine Data Structure
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__Vector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Vector</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffeine__vector__s.html">caffeine_vector_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It keeps their elements contiguous on memory and grow automaticaly when gets full.  <a href="structcaffeine__vector__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga19638efc27ff43b4cc3ccc3a816fb139"><td class="memItemLeft" align="right" valign="top"><a id="ga19638efc27ff43b4cc3ccc3a816fb139"></a>
typedef struct <a class="el" href="structcaffeine__vector__s.html">caffeine_vector_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a></td></tr>
<tr class="memdesc:ga19638efc27ff43b4cc3ccc3a816fb139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar for struct <a class="el" href="structcaffeine__vector__s.html" title="It keeps their elements contiguous on memory and grow automaticaly when gets full.">caffeine_vector_s</a>. <br /></td></tr>
<tr class="separator:ga19638efc27ff43b4cc3ccc3a816fb139"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1f4a6434fd77af483b06bb4698109d19"><td class="memItemLeft" align="right" valign="top">cff_err_e&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga1f4a6434fd77af483b06bb4698109d19">cff_vector_create</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uint64_t data_size, uint64_t lenght, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:ga1f4a6434fd77af483b06bb4698109d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer to the vector and sets its fields properly.  <a href="group__Vector.html#ga1f4a6434fd77af483b06bb4698109d19">More...</a><br /></td></tr>
<tr class="separator:ga1f4a6434fd77af483b06bb4698109d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cecdd9633f50dc2e98432fcf9bf14d5"><td class="memItemLeft" align="right" valign="top">cff_err_e&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga0cecdd9633f50dc2e98432fcf9bf14d5">cff_vector_resize</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uint64_t lenght, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:ga0cecdd9633f50dc2e98432fcf9bf14d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates the buffer owned by the vector.  <a href="group__Vector.html#ga0cecdd9633f50dc2e98432fcf9bf14d5">More...</a><br /></td></tr>
<tr class="separator:ga0cecdd9633f50dc2e98432fcf9bf14d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad32be3ec31b0b04f448208e6ff490555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#gad32be3ec31b0b04f448208e6ff490555">cff_vector_get</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uint64_t index, uintptr_t out)</td></tr>
<tr class="memdesc:gad32be3ec31b0b04f448208e6ff490555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at a give index.  <a href="group__Vector.html#gad32be3ec31b0b04f448208e6ff490555">More...</a><br /></td></tr>
<tr class="separator:gad32be3ec31b0b04f448208e6ff490555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga421c7b446b92e30e9ef01bbd1244b7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga421c7b446b92e30e9ef01bbd1244b7a6">cff_vector_set</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr, uint64_t index)</td></tr>
<tr class="memdesc:ga421c7b446b92e30e9ef01bbd1244b7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value at index position to the value pointed by ptr_in.  <a href="group__Vector.html#ga421c7b446b92e30e9ef01bbd1244b7a6">More...</a><br /></td></tr>
<tr class="separator:ga421c7b446b92e30e9ef01bbd1244b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d097bb02266e3e7ca933bc27fe68788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga4d097bb02266e3e7ca933bc27fe68788">cff_vector_insert</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr, uint64_t index)</td></tr>
<tr class="memdesc:ga4d097bb02266e3e7ca933bc27fe68788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts all elements starting on index position to right and sets the value at index position to the value pointed by ptr_in.  <a href="group__Vector.html#ga4d097bb02266e3e7ca933bc27fe68788">More...</a><br /></td></tr>
<tr class="separator:ga4d097bb02266e3e7ca933bc27fe68788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65c8b850aaf4dfd17560c807a477cfe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga65c8b850aaf4dfd17560c807a477cfe3">cff_vector_remove</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uint64_t index, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:ga65c8b850aaf4dfd17560c807a477cfe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from vector by shifting all elements starting on index position to the left.  <a href="group__Vector.html#ga65c8b850aaf4dfd17560c807a477cfe3">More...</a><br /></td></tr>
<tr class="separator:ga65c8b850aaf4dfd17560c807a477cfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21132014d66ab072e560d01fbf7bbd33"><td class="memItemLeft" align="right" valign="top">cff_err_e&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga21132014d66ab072e560d01fbf7bbd33">cff_vector_copy</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, <a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *to, uint64_t start, uint64_t count, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:ga21132014d66ab072e560d01fbf7bbd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a section of data from one vector to other.  <a href="group__Vector.html#ga21132014d66ab072e560d01fbf7bbd33">More...</a><br /></td></tr>
<tr class="separator:ga21132014d66ab072e560d01fbf7bbd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f8c68a467792e97ae6235ef89534412"><td class="memItemLeft" align="right" valign="top">cff_err_e&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga4f8c68a467792e97ae6235ef89534412">cff_vector_clone</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, <a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *to, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:ga4f8c68a467792e97ae6235ef89534412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all elements from one vector to other.  <a href="group__Vector.html#ga4f8c68a467792e97ae6235ef89534412">More...</a><br /></td></tr>
<tr class="separator:ga4f8c68a467792e97ae6235ef89534412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24521096e2e15b025f3e37e925fd0a2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga24521096e2e15b025f3e37e925fd0a2d">cff_vector_fill</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr)</td></tr>
<tr class="separator:ga24521096e2e15b025f3e37e925fd0a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c084e6e4c297694cfb56ab3363f26c"><td class="memItemLeft" align="right" valign="top">cff_err_e&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga09c084e6e4c297694cfb56ab3363f26c">cff_vector_join</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, <a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *from, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:ga09c084e6e4c297694cfb56ab3363f26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from "other" vector to the vector starting at the end of vector.  <a href="group__Vector.html#ga09c084e6e4c297694cfb56ab3363f26c">More...</a><br /></td></tr>
<tr class="separator:ga09c084e6e4c297694cfb56ab3363f26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9ecbab68f35c5d6dfb68ed7732021a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#gaa9ecbab68f35c5d6dfb68ed7732021a3">cff_vector_reverse</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector)</td></tr>
<tr class="memdesc:gaa9ecbab68f35c5d6dfb68ed7732021a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of elements.  <a href="group__Vector.html#gaa9ecbab68f35c5d6dfb68ed7732021a3">More...</a><br /></td></tr>
<tr class="separator:gaa9ecbab68f35c5d6dfb68ed7732021a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558bd16989627469966f06405ad23c60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga558bd16989627469966f06405ad23c60">cff_vector_filter</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, filter_fn func, <a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *filter_result, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:ga558bd16989627469966f06405ad23c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the elements of an vector and puts the result on other.  <a href="group__Vector.html#ga558bd16989627469966f06405ad23c60">More...</a><br /></td></tr>
<tr class="separator:ga558bd16989627469966f06405ad23c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f475761112e74659c7bd7c7d7c62fb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga7f475761112e74659c7bd7c7d7c62fb1">cff_vector_map</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, map_fn func, <a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *map_result, uint64_t result_data_size, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:ga7f475761112e74659c7bd7c7d7c62fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the elements of an vector and puts the result on other.  <a href="group__Vector.html#ga7f475761112e74659c7bd7c7d7c62fb1">More...</a><br /></td></tr>
<tr class="separator:ga7f475761112e74659c7bd7c7d7c62fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2653271c0ffff6f27e2cf67b0756e6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#gab2653271c0ffff6f27e2cf67b0756e6a">cff_vector_foreach</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, foreach_fn func)</td></tr>
<tr class="memdesc:gab2653271c0ffff6f27e2cf67b0756e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the vector and executes an callback to each element.  <a href="group__Vector.html#gab2653271c0ffff6f27e2cf67b0756e6a">More...</a><br /></td></tr>
<tr class="separator:gab2653271c0ffff6f27e2cf67b0756e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab300b3c32953a348929c6be8b53fd3fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#gab300b3c32953a348929c6be8b53fd3fe">cff_vector_sort</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, comparer_fn predicate)</td></tr>
<tr class="memdesc:gab300b3c32953a348929c6be8b53fd3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order the elements using the quick sort algorithm.  <a href="group__Vector.html#gab300b3c32953a348929c6be8b53fd3fe">More...</a><br /></td></tr>
<tr class="separator:gab300b3c32953a348929c6be8b53fd3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbeb17b00944a561c5b9f10b3a24e058"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#gafbeb17b00944a561c5b9f10b3a24e058">cff_vector_free</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:gafbeb17b00944a561c5b9f10b3a24e058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the buffer allocated to this vector.  <a href="group__Vector.html#gafbeb17b00944a561c5b9f10b3a24e058">More...</a><br /></td></tr>
<tr class="separator:gafbeb17b00944a561c5b9f10b3a24e058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868187340e5fbf1eb6bb67813ad340d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga868187340e5fbf1eb6bb67813ad340d2">cff_vector_clear</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector)</td></tr>
<tr class="memdesc:ga868187340e5fbf1eb6bb67813ad340d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements of the vector.  <a href="group__Vector.html#ga868187340e5fbf1eb6bb67813ad340d2">More...</a><br /></td></tr>
<tr class="separator:ga868187340e5fbf1eb6bb67813ad340d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2833e61c5f6aeca51778caec358a5954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga2833e61c5f6aeca51778caec358a5954">cff_vector_push_back</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:ga2833e61c5f6aeca51778caec358a5954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element at end of the vector.  <a href="group__Vector.html#ga2833e61c5f6aeca51778caec358a5954">More...</a><br /></td></tr>
<tr class="separator:ga2833e61c5f6aeca51778caec358a5954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3414ff38f27c7b84d5c282161b6494"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#gace3414ff38f27c7b84d5c282161b6494">cff_vector_push_front</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:gace3414ff38f27c7b84d5c282161b6494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element at start of the vector, this operation forces all other elements to shift 1 position to the right.  <a href="group__Vector.html#gace3414ff38f27c7b84d5c282161b6494">More...</a><br /></td></tr>
<tr class="separator:gace3414ff38f27c7b84d5c282161b6494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5fd025efccf88ede5706a481764e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#gaac5fd025efccf88ede5706a481764e9d">cff_vector_pop_back</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:gaac5fd025efccf88ede5706a481764e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an element from the end of vector removing it.  <a href="group__Vector.html#gaac5fd025efccf88ede5706a481764e9d">More...</a><br /></td></tr>
<tr class="separator:gaac5fd025efccf88ede5706a481764e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964f10b97640cbe96fa67a6615a67ce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga964f10b97640cbe96fa67a6615a67ce0">cff_vector_pop_front</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr, AllocatorInterface *allocator)</td></tr>
<tr class="memdesc:ga964f10b97640cbe96fa67a6615a67ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an element from the start of vector removing it, this operation forces all other elements to shift 1 position to the left.  <a href="group__Vector.html#ga964f10b97640cbe96fa67a6615a67ce0">More...</a><br /></td></tr>
<tr class="separator:ga964f10b97640cbe96fa67a6615a67ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga589140e58f4cbfbfaabd1a7c166072cd"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga589140e58f4cbfbfaabd1a7c166072cd">cff_vector_equal</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, <a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *other)</td></tr>
<tr class="memdesc:ga589140e58f4cbfbfaabd1a7c166072cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the elements in both arrays are equals and with same order.  <a href="group__Vector.html#ga589140e58f4cbfbfaabd1a7c166072cd">More...</a><br /></td></tr>
<tr class="separator:ga589140e58f4cbfbfaabd1a7c166072cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63dea780b6bec7c0e3ac4aa489f08dc5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga63dea780b6bec7c0e3ac4aa489f08dc5">cff_vector_find</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr, uint64_t *found)</td></tr>
<tr class="memdesc:ga63dea780b6bec7c0e3ac4aa489f08dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of the first ocurrency of the value pointed by ptr_in in vector.  <a href="group__Vector.html#ga63dea780b6bec7c0e3ac4aa489f08dc5">More...</a><br /></td></tr>
<tr class="separator:ga63dea780b6bec7c0e3ac4aa489f08dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d91648c728b6a4a1cb4ed7d446c690a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga2d91648c728b6a4a1cb4ed7d446c690a">cff_vector_find_cmp</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr, uint64_t *found, comparer_fn predicate)</td></tr>
<tr class="memdesc:ga2d91648c728b6a4a1cb4ed7d446c690a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of the first ocurrency of the value pointed by ptr_in in vector.  <a href="group__Vector.html#ga2d91648c728b6a4a1cb4ed7d446c690a">More...</a><br /></td></tr>
<tr class="separator:ga2d91648c728b6a4a1cb4ed7d446c690a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1a5634f2e51cda9a8e271ca2802016"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga4e1a5634f2e51cda9a8e271ca2802016">cff_vector_count</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr)</td></tr>
<tr class="memdesc:ga4e1a5634f2e51cda9a8e271ca2802016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of ocurrencies of elements equals to value pointed by ptr_in.  <a href="group__Vector.html#ga4e1a5634f2e51cda9a8e271ca2802016">More...</a><br /></td></tr>
<tr class="separator:ga4e1a5634f2e51cda9a8e271ca2802016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11aa143b5d9fdcebbdbbf65e279bff98"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga11aa143b5d9fdcebbdbbf65e279bff98">cff_vector_count_cmp</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr, comparer_fn predicate)</td></tr>
<tr class="memdesc:ga11aa143b5d9fdcebbdbbf65e279bff98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of ocurrencies of elements equals to value pointed by ptr_in.  <a href="group__Vector.html#ga11aa143b5d9fdcebbdbbf65e279bff98">More...</a><br /></td></tr>
<tr class="separator:ga11aa143b5d9fdcebbdbbf65e279bff98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c3f5afdfb21120c6b2a2a0975039905"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga0c3f5afdfb21120c6b2a2a0975039905">cff_vector_any</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr)</td></tr>
<tr class="memdesc:ga0c3f5afdfb21120c6b2a2a0975039905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the ocurrency of value pointed by ptr_in on the vector.  <a href="group__Vector.html#ga0c3f5afdfb21120c6b2a2a0975039905">More...</a><br /></td></tr>
<tr class="separator:ga0c3f5afdfb21120c6b2a2a0975039905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37be23a12f7fca6293f40335b146b49"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#gaa37be23a12f7fca6293f40335b146b49">cff_vector_any_cmp</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr, comparer_fn predicate)</td></tr>
<tr class="memdesc:gaa37be23a12f7fca6293f40335b146b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the ocurrency of value pointed by ptr_in on the vector.  <a href="group__Vector.html#gaa37be23a12f7fca6293f40335b146b49">More...</a><br /></td></tr>
<tr class="separator:gaa37be23a12f7fca6293f40335b146b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293dfd9b70a1ccad919304e7e89eca63"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#ga293dfd9b70a1ccad919304e7e89eca63">cff_vector_all</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr)</td></tr>
<tr class="memdesc:ga293dfd9b70a1ccad919304e7e89eca63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all vector elements are equals to value pointed by ptr_in.  <a href="group__Vector.html#ga293dfd9b70a1ccad919304e7e89eca63">More...</a><br /></td></tr>
<tr class="separator:ga293dfd9b70a1ccad919304e7e89eca63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2adf1bcc9b47102eae6905c79a32063"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vector.html#gaf2adf1bcc9b47102eae6905c79a32063">cff_vector_all_cmp</a> (<a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *vector, uintptr_t data_ptr, comparer_fn predicate)</td></tr>
<tr class="memdesc:gaf2adf1bcc9b47102eae6905c79a32063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all vector elements are equals to value pointed by ptr_in.  <a href="group__Vector.html#gaf2adf1bcc9b47102eae6905c79a32063">More...</a><br /></td></tr>
<tr class="separator:gaf2adf1bcc9b47102eae6905c79a32063"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga293dfd9b70a1ccad919304e7e89eca63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga293dfd9b70a1ccad919304e7e89eca63">&#9670;&nbsp;</a></span>cff_vector_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t cff_vector_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if all vector elements are equals to value pointed by ptr_in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Pointer to data to be find in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Retuns 1 if all elements are equal to value pointed by ptr_in, otherwise returns 0. </dd></dl>

</div>
</div>
<a id="gaf2adf1bcc9b47102eae6905c79a32063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2adf1bcc9b47102eae6905c79a32063">&#9670;&nbsp;</a></span>cff_vector_all_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t cff_vector_all_cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comparer_fn&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if all vector elements are equals to value pointed by ptr_in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Pointer to data to be find in the vector. </td></tr>
    <tr><td class="paramname">predicate</td><td>[in] Callback used to compare the elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Retuns 1 if all elements are equal to value pointed by ptr_in, otherwise returns 0. </dd></dl>

</div>
</div>
<a id="ga0c3f5afdfb21120c6b2a2a0975039905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c3f5afdfb21120c6b2a2a0975039905">&#9670;&nbsp;</a></span>cff_vector_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t cff_vector_any </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the ocurrency of value pointed by ptr_in on the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Pointer to data to be find in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Retuns 1 if there is at least one ocurrency, otherwise returns 0. </dd></dl>

</div>
</div>
<a id="gaa37be23a12f7fca6293f40335b146b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa37be23a12f7fca6293f40335b146b49">&#9670;&nbsp;</a></span>cff_vector_any_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t cff_vector_any_cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comparer_fn&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the ocurrency of value pointed by ptr_in on the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Pointer to data to be find in the vector. </td></tr>
    <tr><td class="paramname">predicate</td><td>[in] Callback used to compare the elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Retuns 1 if there is at least one ocurrency, otherwise returns 0. </dd></dl>

</div>
</div>
<a id="ga868187340e5fbf1eb6bb67813ad340d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga868187340e5fbf1eb6bb67813ad340d2">&#9670;&nbsp;</a></span>cff_vector_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f8c68a467792e97ae6235ef89534412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f8c68a467792e97ae6235ef89534412">&#9670;&nbsp;</a></span>cff_vector_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cff_err_e cff_vector_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies all elements from one vector to other. </p>
<p>If the allocator parameter is NULL this function will get the default allocator setted in Caffeine-Core library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">to</td><td>[out] Pointer to an vector that will receive the copy </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cff_err_e A cff_err_e indicating if any error ocurred. </dd></dl>

</div>
</div>
<a id="ga21132014d66ab072e560d01fbf7bbd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21132014d66ab072e560d01fbf7bbd33">&#9670;&nbsp;</a></span>cff_vector_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cff_err_e cff_vector_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a section of data from one vector to other. </p>
<p>If the allocator parameter is NULL this function will get the default allocator setted in Caffeine-Core library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">to</td><td>[out] Pointer to an vector that will receive the copy </td></tr>
    <tr><td class="paramname">start</td><td>[in] Index from where the copy process will start </td></tr>
    <tr><td class="paramname">count</td><td>[in] How many elements to copy from start. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cff_err_e A cff_err_e indicating if any error ocurred. </dd></dl>

</div>
</div>
<a id="ga4e1a5634f2e51cda9a8e271ca2802016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e1a5634f2e51cda9a8e271ca2802016">&#9670;&nbsp;</a></span>cff_vector_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cff_vector_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of ocurrencies of elements equals to value pointed by ptr_in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Pointer to data to be count in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t The number of ocurrencies of elements equals to value pointed by ptr_in. </dd></dl>

</div>
</div>
<a id="ga11aa143b5d9fdcebbdbbf65e279bff98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11aa143b5d9fdcebbdbbf65e279bff98">&#9670;&nbsp;</a></span>cff_vector_count_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cff_vector_count_cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comparer_fn&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of ocurrencies of elements equals to value pointed by ptr_in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Pointer to data to be count in the vector. </td></tr>
    <tr><td class="paramname">predicate</td><td>[in] Callback used to compare the elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t The number of ocurrencies of elements equals to value pointed by ptr_in. </dd></dl>

</div>
</div>
<a id="ga1f4a6434fd77af483b06bb4698109d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f4a6434fd77af483b06bb4698109d19">&#9670;&nbsp;</a></span>cff_vector_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cff_err_e cff_vector_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lenght</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer to the vector and sets its fields properly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_size</td><td>[in] The size in bytes of each element. </td></tr>
    <tr><td class="paramname">lenght</td><td>[in] The max number of elements the vector will have. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cff_err_e A cff_err_e indicating if any error ocurred. </dd></dl>

</div>
</div>
<a id="ga589140e58f4cbfbfaabd1a7c166072cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga589140e58f4cbfbfaabd1a7c166072cd">&#9670;&nbsp;</a></span>cff_vector_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t cff_vector_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the elements in both arrays are equals and with same order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">other</td><td>[in] Pointer to other vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Returns 0 if false and 1 if true. </dd></dl>

</div>
</div>
<a id="ga24521096e2e15b025f3e37e925fd0a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24521096e2e15b025f3e37e925fd0a2d">&#9670;&nbsp;</a></span>cff_vector_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Adress from where the data will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga558bd16989627469966f06405ad23c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga558bd16989627469966f06405ad23c60">&#9670;&nbsp;</a></span>cff_vector_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">filter_fn&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>filter_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters the elements of an vector and puts the result on other. </p>
<p>Creates a new vector based on an existing one, the elements of the new vector must complies the filter_function criteria. If the allocator parameter is NULL this function will get the default allocator setted in Caffeine-Core library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">func</td><td>[in] Callback that determines if the element complies the criteria for the new vector. </td></tr>
    <tr><td class="paramname">filter_result</td><td>[out] Pointer to the vector that will receive the filtered elements. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63dea780b6bec7c0e3ac4aa489f08dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63dea780b6bec7c0e3ac4aa489f08dc5">&#9670;&nbsp;</a></span>cff_vector_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t cff_vector_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index of the first ocurrency of the value pointed by ptr_in in vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Pointer to data to find in the vector. </td></tr>
    <tr><td class="paramname">found</td><td>[out] Receives the index where the value was found. If not found the value at its adress will not change. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Returns 0 if false and 1 if true. </dd></dl>

</div>
</div>
<a id="ga2d91648c728b6a4a1cb4ed7d446c690a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d91648c728b6a4a1cb4ed7d446c690a">&#9670;&nbsp;</a></span>cff_vector_find_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t cff_vector_find_cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>found</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comparer_fn&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index of the first ocurrency of the value pointed by ptr_in in vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Pointer to data to be find in the vector. </td></tr>
    <tr><td class="paramname">found</td><td>[out] Receives the index where the value was found. If not found the value at its adress will not change. </td></tr>
    <tr><td class="paramname">predicate</td><td>[in] Callback used to compare the elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Returns 0 if false and 1 if true. </dd></dl>

</div>
</div>
<a id="gab2653271c0ffff6f27e2cf67b0756e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2653271c0ffff6f27e2cf67b0756e6a">&#9670;&nbsp;</a></span>cff_vector_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">foreach_fn&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over the vector and executes an callback to each element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">func</td><td>[in] Callback that will be called for every element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafbeb17b00944a561c5b9f10b3a24e058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbeb17b00944a561c5b9f10b3a24e058">&#9670;&nbsp;</a></span>cff_vector_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the buffer allocated to this vector. </p>
<p>If the allocator parameter is NULL this function will get the default allocator setted in Caffeine-Core library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad32be3ec31b0b04f448208e6ff490555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad32be3ec31b0b04f448208e6ff490555">&#9670;&nbsp;</a></span>cff_vector_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value at a give index. </p>
<p>Copies the data present at the index position to the adress pointed by ptr_out. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">index</td><td>[in] Position of the data inside the vector buffer. </td></tr>
    <tr><td class="paramname">out</td><td>[out] Adress where the data will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d097bb02266e3e7ca933bc27fe68788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d097bb02266e3e7ca933bc27fe68788">&#9670;&nbsp;</a></span>cff_vector_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts all elements starting on index position to right and sets the value at index position to the value pointed by ptr_in. </p>
<p>This function will copy the content at ptr_in adress to the location indicated by index. Keep in mind that all elements on index position and after will be sihfted by one position to the right, it means that the value at the last index will be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Adress from where the data will be copied. </td></tr>
    <tr><td class="paramname">index</td><td>[in] Position of the data inside the vector buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09c084e6e4c297694cfb56ab3363f26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09c084e6e4c297694cfb56ab3363f26c">&#9670;&nbsp;</a></span>cff_vector_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cff_err_e cff_vector_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements from "other" vector to the vector starting at the end of vector. </p>
<p>If the lenght of "other" added to start_at is greater than vector lenght the vector will be resized. If the allocator parameter is NULL this function will get the default allocator setted in Caffeine-Core library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">from</td><td>[in] Pointer to an vector to be joined to "vector" at end of vector. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cff_err_e A cff_err_e indicating if any error ocurred. </dd></dl>

</div>
</div>
<a id="ga7f475761112e74659c7bd7c7d7c62fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f475761112e74659c7bd7c7d7c62fb1">&#9670;&nbsp;</a></span>cff_vector_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map_fn&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>map_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>result_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the elements of an vector and puts the result on other. </p>
<p>Creates a new vector based on an existing one, the elements of the new vector will be the result from map_function when called passed an element from vector in the parameters. If the allocator parameter is NULL this function will get the default allocator setted in Caffeine-Core library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">func</td><td>[in] Callback that defines how to transform from one type to other. </td></tr>
    <tr><td class="paramname">map_result</td><td>[out] Pointer to the vector that will receive the mapped elements. </td></tr>
    <tr><td class="paramname">result_data_size</td><td>[in] The size in bytes of the target type. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac5fd025efccf88ede5706a481764e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac5fd025efccf88ede5706a481764e9d">&#9670;&nbsp;</a></span>cff_vector_pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_pop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an element from the end of vector removing it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[out] Adress where the data will be copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga964f10b97640cbe96fa67a6615a67ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga964f10b97640cbe96fa67a6615a67ce0">&#9670;&nbsp;</a></span>cff_vector_pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an element from the start of vector removing it, this operation forces all other elements to shift 1 position to the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[out] Adress where the data will be copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2833e61c5f6aeca51778caec358a5954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2833e61c5f6aeca51778caec358a5954">&#9670;&nbsp;</a></span>cff_vector_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element at end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Adress from where the data will be copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gace3414ff38f27c7b84d5c282161b6494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace3414ff38f27c7b84d5c282161b6494">&#9670;&nbsp;</a></span>cff_vector_push_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element at start of the vector, this operation forces all other elements to shift 1 position to the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Adress from where the data will be copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65c8b850aaf4dfd17560c807a477cfe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65c8b850aaf4dfd17560c807a477cfe3">&#9670;&nbsp;</a></span>cff_vector_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an element from vector by shifting all elements starting on index position to the left. </p>
<p>This function shifts all elements starting on index to the left, (eg. vector[i] = vector[i+1]). If the index is equals to lenght - 1 (last element) the function just returns. Keep in mind thet when an element (except at lenght - 1 ) is removed, there will exist two copies of the last element at the end of the vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">index</td><td>[in] Position of the data inside the vector buffer. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0cecdd9633f50dc2e98432fcf9bf14d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cecdd9633f50dc2e98432fcf9bf14d5">&#9670;&nbsp;</a></span>cff_vector_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cff_err_e cff_vector_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lenght</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorInterface *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocates the buffer owned by the vector. </p>
<ul>
<li>The size of memory allocated is equals to data_size * lenght in bytes, notes that data_size is the value informed when cff_array_create is called. If the allocator parameter is NULL this function will get the default allocator setted in Caffeine-Core library.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">lenght</td><td>[in] The new max number of elements the vector will have. </td></tr>
    <tr><td class="paramname">allocator</td><td>[in] Pointer to a custom allocator. If NULL is setted the function will use the default allocator from Caffeine-Core library. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cff_err_e A cff_err_e indicating if any error ocurred. </dd></dl>

</div>
</div>
<a id="gaa9ecbab68f35c5d6dfb68ed7732021a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9ecbab68f35c5d6dfb68ed7732021a3">&#9670;&nbsp;</a></span>cff_vector_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the order of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga421c7b446b92e30e9ef01bbd1244b7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga421c7b446b92e30e9ef01bbd1244b7a6">&#9670;&nbsp;</a></span>cff_vector_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value at index position to the value pointed by ptr_in. </p>
<p>This function will copy the content at ptr_in adress to the location indicated by index. Keep in mind that the current value present at index position will be overwrited.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>[in] Adress from where the data will be copied. </td></tr>
    <tr><td class="paramname">index</td><td>[in] Position of the data inside the vector buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab300b3c32953a348929c6be8b53fd3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab300b3c32953a348929c6be8b53fd3fe">&#9670;&nbsp;</a></span>cff_vector_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_vector_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vector.html#ga19638efc27ff43b4cc3ccc3a816fb139">cff_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comparer_fn&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Order the elements using the quick sort algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>[in] Pointer to a vector. </td></tr>
    <tr><td class="paramname">predicate</td><td>[in] Callback used to compare the elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
